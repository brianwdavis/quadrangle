#' Scan a file or image for QR codes.
#' 
#' \code{qr_scan} reads in an image file or \code{magick} image object and first
#' tries to read it using the C++ engine, which is fast and robust at locating
#' the alignment patterns. However, it is less robust at decoding. If no codes
#' can be read, the image and corners are passed to the JS engine, which is
#' slower but has a higher success rate on cropped images.
#'
#' This function calls \code{\link{qr_scan_cpp}} and
#' \code{\link{qr_scan_js_from_corners}}, which each have a \code{while} loop
#' that progressively pushes mid-brightness pixels to pure black. This algorithm
#' was developed for identifying QR codes on white printed sheets in outdoor
#' images. To BYO algorithm, you can use those two functions as templates. For
#' example, \code{\link{image_threshold}} with \code{(..., type = "white")} to
#' lighten dark images, or \code{\link{image_morphology}} with \code{(...,
#' morphology = "Open", kernel = "Square:7")}. A more thoughtful API for
#' developing these algorithms is a work in progress.
#' 
#' 
#' 
#' @param image A path to a \code{magick}-readable file, e.g. jpg or png, or a \code{magick} object.
#' @param flop  Logical. Should the image be mirrored L-R before reading?
#' @param plot  Logical. Should the image with any detected codes be shown after reading? (Requires ggplot2)
#' @param force_js Logical. Should the JS library run even if the C++ library is able to read the code?
#' @param no_js Logical. Never use the JS library, even if no QR codes are decoded.
#' @return A list of dataframes, \strong{values} and \strong{points}, each with a column \strong{id}. 
qr_scan <- function(image, flop = T, plot = F, force_js = F, no_js = F) {
  if (is.character(image)) {
    mgk <- image_read(image)
  } else if ("magick-image" %in% class(image)) {
    mgk <- image
  } else {
    stop("Supply either an image file path or a magick image object.")
  }
  
  if (flop) {
    mgk <- image_flop(mgk)
  }
  
  code_obj <- qr_scan_cpp(mgk, flop = F)
  code_pts <- code_obj$points
  
  # TODO image_destroy(mgk)
  
  if (isTRUE(nrow(code_pts) > 0) && any(code_obj$values$value == "") || force_js) {
    if (!no_js) {
      code_list <- split(code_pts, code_pts$id)
      code_obj <- 
        map(code_list, ~qr_scan_js_from_corners(mgk, .x)) %>% 
        qr_parse_js()
    }
  } 
  
  if (plot && requireNamespace("ggplot2", quietly = T)) {
    print(qr_plot(mgk, code_obj))
  }
  
  return(code_obj)
}


#' Plot a \code{magick} image with any detected QR codes.
#' 
#' \code{qr_plot} is a helper called inside \code{qr_scan} to visualize images
#' and any QR codes. Requires \code{ggplot2}.
#' 
#' @param mgk       The image object that was scanned.
#' @param code_obj  A list of dataframes, \strong{values} and \strong{points}, generated by \code{qr_scan}.
#' @return A ggplot object.
qr_plot <- function(mgk, code_obj) {
  if (!requireNamespace("ggplot2", quietly = T)) {
    stop("Plotting decoded QR images requires ggplot2.")
  }
  
  dat <- full_join(code_obj$values, code_obj$points)
  
  # slow to resize large images, but slow to render them as well, how to fix?
  if (image_info(mgk)$width > 1000) {
    mgk <- image_resize(mgk, "50%")
    dat$x <- dat$x/2
    dat$y <- dat$y/2
  }
  
  image_ggplot(mgk) +
    ggplot2::geom_point(
      data = dat,
      ggplot2::aes(x, y, color = as.character(id)),
      show.legend = F, size = 4
    ) +
    ggplot2::geom_label(
      data = dat %>%
        group_by(id, value) %>%
        summarise_at(vars(x, y), list(mean)),
      ggplot2::aes(x, y, label = value),
      fontface = "bold"
    )
}