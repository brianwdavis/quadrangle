#' Scan an image within a restricted geometry context.
#' 
#' This function is usually only called by \code{qr_scan}, when a pattern is
#' detected, but decoding it fails. It crops the original image to the 
#' neighborhood of pixels targeting the patterns, and re-scans only that region
#' using the JS library. If your images are particularly high-resolution, this
#' will resize them to 50\%, which seems to increase the chances of recognition.
#' 
#' The algorithm used here was originally developed to identify QR codes on
#' white printed sheets in outdoor images, so images are progressively darkened
#' to recover data in overexposed regions. You may need to view the source of
#' this function to get a template for developing your own algorithm in other
#' lighting conditions. For example, \code{\link{image_threshold}} with
#' \code{(..., type = "white")} to lighten dark images, or
#' \code{\link{image_morphology}} with \code{(..., morphology = "Open",
#' kernel = "Square:7")}. A more thoughtful API for developing these algorithms
#' is a work in progress.
#' 
#' @param mgk      A magick image object.
#' @param code_pts A dataframe of columns \strong{x} and \strong{y}, with each row identifying a QR pattern corner, usually generated by \code{qr_scan_cpp_magick}.
#' @return If decodable, a list with metadata about the identified QR code.
qr_scan_js_from_corners <- function(mgk, code_pts) {

  parsedcorners <- qr_parse_corners_(mgk, code_pts)
  mgk <- parsedcorners$mgk
  
  codes <- list()
  thr <- paste0(c(0,50,60,70,80,90,95), "%")
  i <- 0
  
  while (length(codes) == 0 & i < length(thr)) {
    i <- i+1
    
    codes <- image_threshold(mgk, "black", thr[i]) %>% 
      image_data(channels = "rgba") %>% 
      qr_scan_js_array()
    
  }
  
  if (length(codes) != 0) {
    codes$darkened <- thr[i]
    codes$resized <- parsedcorners$resize_flag
    
    if (parsedcorners$resize_flag) {
      codes$location$x <- codes$location$x * 2
      codes$location$y <- codes$location$y * 2
    }
    
    codes$location$x <- codes$location$x + parsedcorners$anc_x
    codes$location$y <- codes$location$y + parsedcorners$anc_y
  }
  codes
}

#' (Internal) Crop and resize large images to QR corner neighborhoods
#' 
#' This is an internal function used by \code{\link{qr_scan_js_from_corners}}.
#' 
#' @keywords internal
#' 
#' @param mgk      A magick image object.
#' @param code_pts A dataframe of columns \strong{x} and \strong{y}, with each row identifying a QR pattern corner, usually generated by \code{qr_scan_cpp_magick}.
#' @return A list with the altered image, the \strong{x}/\strong{y} anchor pixels, and a resizing flag
qr_parse_corners_ <- function(mgk, code_pts) {
  ret <- 
    sapply(
      c("mgk", "anc_x", "anc_y", "resize_flag"), 
      function(x) FALSE,
      simplify = F
      )
  
  if (nrow(code_pts) != 0) {
    ret$anc_x <- max(min(code_pts$x) - 50, 0)
    ret$anc_y <- max(min(code_pts$y) - 50, 0)
    
    dim_x <- min(diff(range(code_pts$x)) + 100, image_info(mgk)$width-ret$anc_x)
    dim_y <- min(diff(range(code_pts$y)) + 100, image_info(mgk)$height-ret$anc_y)
    
    ret$resize_flag <- max(dim_x, dim_y) > 400
    
    geo <- glue::glue("{dim_x}x{dim_y}+{ret$anc_x}+{ret$anc_y}")
    
    mgk <- image_crop(mgk, geo)
    
    if (ret$resize_flag) {
      mgk <- image_resize(mgk, "50%")
    }
  }
  
  ret$mgk <- mgk
  return(ret)
}

#' Parse multiple QR objects into a single dataframe.
#' 
#' This function is usually only called by \code{\link{qr_scan}}, to combine multiple
#' objects returned by \code{\link{qr_scan_js_from_corners}} into a single dataframe,
#' analogous to the output from \code{rcpp_qr_scan_array} or \code{qr_scan_cpp_*}.
#' @param lst A list returned by \code{\link{qr_scan_js_from_corners}}, with dataframe elements \strong{chunks} and \strong{location}.
#' @return If not empty, a list with two dataframe elements, \strong{values} and \strong{points}, identifying all QR codes from an image.
qr_parse_js <- function(lst) {
  result <- list()
  
  result$values <- 
    map(lst, "chunks") %>% 
    bind_rows(.id = "id") 
  result$values$bytes <- NULL
  
  names(result$values) <- c("id", "type", "value")[seq_along(names(result$values))]

  result$points <- 
    map(lst, "location") %>% 
    bind_rows(.id = "id")
  
  result
}