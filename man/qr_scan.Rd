% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qr_scan.R
\name{qr_scan}
\alias{qr_scan}
\title{Scan a file or image for QR codes.}
\usage{
qr_scan(image, flop = T, plot = F, force_js = F, no_js = F)
}
\arguments{
\item{image}{A path to a \code{magick}-readable file, e.g. jpg or png, or a \code{magick} object.}

\item{flop}{Logical. Should the image be mirrored L-R before reading?}

\item{plot}{Logical. Should the image with any detected codes be shown after reading? (Requires ggplot2)}

\item{force_js}{Logical. Should the JS library run even if the C++ library is able to read the code?}

\item{no_js}{Logical. Never use the JS library, even if no QR codes are decoded.}
}
\value{
A list of dataframes, \strong{values} and \strong{points}, each with a column \strong{id}.
}
\description{
\code{qr_scan} reads in an image file or \code{magick} image object and first
tries to read it using the C++ engine, which is fast and robust at locating
the alignment patterns. However, it is less robust at decoding. If no codes
can be read, the image and corners are passed to the JS engine, which is
slower but has a higher success rate on cropped images.
}
\details{
This function calls \code{\link{qr_scan_cpp}} and
\code{\link{qr_scan_js_from_corners}}, which each have a \code{while} loop
that progressively pushes mid-brightness pixels to pure black. This algorithm
was developed for identifying QR codes on white printed sheets in outdoor
images. To BYO algorithm, you can use those two functions as templates. For
example, \code{\link{image_threshold}} with \code{(..., type = "white")} to
lighten dark images, or \code{\link{image_morphology}} with \code{(...,
morphology = "Open", kernel = "Square:7")}. A more thoughtful API for
developing these algorithms is a work in progress.
}
